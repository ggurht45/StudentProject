matrices can represent rotations. wow. mind blown.
[   cos(ang)  -sin(ang)
    sin(ang)    cos(ang ]
this matrix represents a rotation around the origin in 2D. given any point/vector or line.
or even shape probably. you can rotate it around the origin by any angle (Matrix)(point) = new point . note order of multip. matters.
see jmtPatrick: Rotation Matrices

wow. khan academy was very useful also. linear transformation. category theory popping up again. how is linearity defined by scaler multip and L(a+b) = La + Lb.
 it seem a weird way to define "linear" trans. could look into more later.
 other than that, the video was awesome "Rotations in R2 Khan academy"



 //sometimes need to do ctrl save for the import hint to come up

 pitch and yaw angles seem to default to 180, when given 0,1,0. weird


 //need to get projections onto some plane and then take their mag. also take mag of original vector. -> 1. projection mag /1 = proj mag.

 //what the heck! -0.0f... sheesh! pitch makes sense.



***********
tried working with cross product and setting rotations one after the other. didnt work. need to do all the rotations at once around an axis.

leap motion cs is NOT equal to javafx cs. --> cause for concern. but now largerly mitigated by using Jose Pereda's function.

learning linear algebra. understanding matrix transformations. rotational matrixces. deriving the 3d rot matrix. javafx sucks. doesnt support pitch roll yaw.
their docs page on rotate not very good.
found jose Pereda's blog post and stackoverflow answer. radians. passing in arguments order. understanding matrix derivation. -still didnt work exactly as i wanted

but i found that i can work with pitch yaw and roll. at least with the hand pointing right. but now the problem is getting the correct pitch, roll and yaw angles?


found bugs!?? in leap motion axises. -0.0f ??! 180* pitch. (1, 0, 0) vs (1, 0, -0.0f) crazy stuff.
still working on understanding the roll angle derivation from leap motion.

may have to fix this "leap motion" code by my self by writing wrapper methods. need more time.


            --comment about yaxis being wrong
leap motions Vector.yAxis gives (0,1,0). this is NOT the y-axis in the lm cs. its the y-axis. in the javafx cs. found this out through the bug in their roll
angle. also their webpage documentation is wrong.

quote from their site:
    The origin is centered at the center of the Leap Motion Controller. The x- and z-axes lie in the horizontal plane,
     with the x-axis running parallel to the long edge of the device. The y-axis is vertical, with positive values
     increasing upwards (in contrast to the downward orientation of most computer graphics coordinate systems).

i also found a pic online of right hand cs vs left hand. thumb index middle fingers on both hands are mapped to x, y, z. RESPECTIVELY.
I will put the pic in this project for later reference
--------------




javafx camera cs, vs lhcs, vs lmcs (supposedly rhcs)
need to clarify the coordinate systems. causes unnecessary headaches




[ ---------------------------------- Notes about Pitch

*need to rethink my ideas about pitch. take hand pointing to the right for example. what is the pitch. its 0. for hand point into -z. pitch is also 0.
thats fine. one of things i should do when i get the pitch from the direction is subtract it from 90 to get the angle to "pitch up to". so in both of these
cases it would be (90-0) = 90. -> this is the angle to "pitch up to". so to recap. get pitch from direction, no need to weigh it i think, the original is fine
and in fact the orginal is perferred. if we weight it, it may introduce error. come back and think about this again later(@1). after getting pitch from direction,
subtract it from 90. so if we got a pitch of 60. then our "pitch up" angle is 90-60 = 30. if we got -60, -> 90- (-60) = 150.

ok, the above note seems to make sense. need to try it.



@1. so did come back and think about it again. i think the weights are in fact needed. think fingers to the right hand. most of the direction vector is in the
xaxis. the tiny portions that project onto the yz plane calculate a big pitch. this pitch needs to be tempered by how much of the direction vector causes it.
if we have a direction in 45 x(-z) plane. then a small y will give bigger pitch? try this and come back and update my thinking. also i know how to minimize
pitch for fpr hand, but what about the hand 45 x(-z) with slight y. how do i minimize this hand's pitch. i think the answer lies in having to use the normal.


*anther point. need to account for +z coordinate in the direction. pitch seems to hit the fan when it detects a +z coordinate. need to take this into account
and make sure i calculate pitch appropriately.


*another point. fingers pointing to the right hand(fpr from now on). roll 90 up. yaw 90 to the right. pitch back or forward by a little amount.
multiply mags by 90:
p-> 20
y -> 88
r -> 90
--test passes for right hand.
double r = 88;  //around z
double p_moreLikeYaw = -90; //rotation around x axis --> seems to be around y... --> nope here, it seems to be around x axix? check again to make sure... nono i was wrong. it does seem to be around y. looking like  a good sign ^^.
double y_moreLikePitch = 20;  //around y --> seems to be around x... --> here it seems to be around y. check again to make sure.

this ^above point doesnt seem to take pitch into consideration. hmm. so how did it come into my calculation earlier. will have to think more.
hm.. just thinking for fpr. we only have a 90 deg yaw. we undo that 90* yaw. then we have "pitch up to" angle of 90*.




(the original pitch needs to be multiplied by the % on the z axis.)
pitch angle is too heck low. --remember Luke. trying to hit 90 for pitch, we are
p -> .96 * (90- (-16.57))                --direction weight from -zAxis(lm) * (total angle to move upwards)

----------------------------    End notes about Pitch ----------------------------------]


[ ---------------------------------- Notes about Roll

think about roll soon. its tricky. imagine left hand handshake position. maybe it needs no weight. hmm. need to think more.
i think we need to use the normal to the palm. in handshake postion normal would extend to the right. projection to the xy plane
will be on the x axis almost. now angle from (yaxis lhcs) to xaxis is 90. also from (yaxis rhcs) to xaxis is 90.
so roll in lefthand in handshake pos is 90*. check later to confirm.

* another insight. getting roll from direction doesnt tell us much. since it will be a projection onto the xy plane, if the hand is pointed in space
it may be concluded that there is a roll, when in fact there wouldnt really be. think 45 in x, y, -z [rhcs]. if this is the direction, then a 45 degree
angle on the xy plane from the projection would be counted as a ROLL?? no that shouldnt be taken as a roll i think. can confirm later.

* so we should only get roll from the normal to the palm. and then also dont need to do any weighting and stuff. but just for learning purposes, i should
continue to show the roll from teh direction vector also. i can label it as "FAKE Roll" not fake news. this will help to illustrate and sink in why its useless
even with the "weighing" procedure.


*palm mormal may not always be useful when getting the roll. think left hand in handshake position point to the right (x-axis)
in this position the palm normal be parallel to the z-axis, thus the roll caculated woudl be 0. when it is obviously not zero.

hmm.. so ^^, things make more sense. i think i know how to get pitch and roll now.
r -> 0.05 * (                            --direction weight from xAxis(lm) * (total angle to move upwards)

----------------------------    End notes about Roll ----------------------------------]

!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!

main thing i am noticing. getting the correct pitch, roll angles is not as easy as lm would have you believe. its good im thinking about it critcally. can
hopefully solve the problem and write about it in my paper.


@2 -lets call this the plane position

i think i can explain to my Professor this tricky problem. start with palm facing -z. we understand that to be 0 pitch, roll, yaw.(@2) sadly that is not the case
in lm. roll is 180. then we think oh have to use palm normal for roll. cool. but then we realize that palm normal for hand in handshake position pointing to
right (direction of positive x-axis) is parallel with z-axis and therefore 0 in the xy plane. so i need to think of a different way for getting the roll in
this situation.

it would be really nice if i made a class that got all the correct pitch roll and yaw angles for a hand in a given orientation. how would i know they are
correct? i would need to verify the logic and results some how. I CAN NOT TRUST LM!!! <- MAIN MORAL OF THE STORY. (i think lm mostly expects user's palm to
face foward. this expectation goes out the window for us.)

!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!

y -> 0.28 *                              --direction weight from -zAxis(lm) * (total angle to move upwards)



------------------------
i can show that i made a simple hand to try to figure it out. i couldn't use the normal hands because setting their direction was a hassle. palm normal
hand direction dont update. so it was more convienient to try to figure out rotations for a simple easily updateable object.



------------------------END